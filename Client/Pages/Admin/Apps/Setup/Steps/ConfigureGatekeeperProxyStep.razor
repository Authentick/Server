@implements IStep
@implements IDisposable

@using AuthServer.Shared

@inject AuthServer.Shared.ConnectivityCheckService.ConnectivityCheckServiceClient ConnectivityCheckServiceClient

<h2>Configure Gatekeeper Proxy</h2>

<p>Gatekeeper Proxy will act as an Identity Aware Proxy in front of your application.</p>
<p><strong>Note:</strong> You will have to point the chosen domain name to Gatekeeper Proxy.</p>

<br />

<EditForm EditContext="@editContext">
    <DataAnnotationsValidator />

    <InputText @bind-Value="gatekeeperProxySettings.PublicDomainName" class="form-control bg-secondary"
        placeholder="Public hostname (e.g. example.com)" />
    @if(!_isValidPublicHostname) {
        <p>Public hostname doesn't resolve to this host.</p>
    }
    <br />

    <InputText @bind-Value="gatekeeperProxySettings.InternalDomainName" type="email" class="form-control bg-secondary"
        placeholder="Internal hostname (e.g. 192.168.1.5)" />
</EditForm>

@code {
    [Parameter]
    public SetupAppStateMachine StateMachine { get; set; } = null!;

    internal GatekeeperProxySettings gatekeeperProxySettings = new GatekeeperProxySettings();
    private EditContext? editContext;
    private bool _isValidPublicHostname;

    private EventHandler<Microsoft.AspNetCore.Components.Forms.FieldChangedEventArgs> HandleFieldChangedAction => async (s, e) => await HandleFieldChanged(s, e);

    protected override void OnInitialized()
    {
        editContext = new EditContext(gatekeeperProxySettings);
        editContext.OnFieldChanged += HandleFieldChangedAction;
    }

    public void Dispose()
    {
        if(editContext != null) {
            editContext.OnFieldChanged -= HandleFieldChangedAction;
        }
    }

    private async Task HandleFieldChanged(object sender, FieldChangedEventArgs e)
    {
        if (editContext != null)
        {
            bool formValid = editContext.Validate();
            if (formValid)
            {
                IsPublicAccessibleRequest request = new IsPublicAccessibleRequest{
                    Hostname = gatekeeperProxySettings.PublicDomainName,
                };

                IsPublicAccessibleReply reply = await ConnectivityCheckServiceClient.IsPublicAccessibleAsync(request);
                
                if(reply.State != IsPublicAccessibleReply.Types.AccessibleReplyEnum.Success) {
                    _isValidPublicHostname = false;
                    StateMachine.SetNextStep(null);
                } else {
                    _isValidPublicHostname = true;
                    StateMachine.SetNextStep(new ChooseDirectoryMethodStep());
                }
            }
            else
            {
                StateMachine.SetNextStep(null);
            }
        }
    }

    internal class GatekeeperProxySettings
    {
        [Required]
        public string? PublicDomainName { get; set; }

        [Required]
        public string? InternalDomainName { get; set; }
    }
}
